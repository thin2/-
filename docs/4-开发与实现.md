# 4. 开发与实现

## 4.1 开发环境

### 4.1.1 硬件要求

#### 开发环境
- **CPU**：Intel i5或同等性能以上
- **内存**：8GB RAM以上
- **存储**：至少10GB可用空间
- **网络**：稳定的互联网连接（用于AI API调用）

#### 生产环境
- **CPU**：2核以上
- **内存**：2GB RAM以上
- **存储**：至少20GB可用空间（根据用户数据量调整）
- **网络**：稳定的互联网连接，带宽至少10Mbps

### 4.1.2 软件环境

#### 操作系统
- **开发**：Windows 10/11、macOS 10.15+、Linux Ubuntu 18.04+
- **生产**：Linux（推荐Ubuntu 20.04+）

#### Python环境
- **Python版本**：3.8+
- **包管理**：pip
- **虚拟环境**：venv（推荐）

#### 数据库
- **SQLite**：3.x（Python内置，无需单独安装）
- **可选**：MySQL 5.7+、PostgreSQL 10+（如需迁移）

#### 浏览器
- **开发测试**：Chrome、Firefox、Safari、Edge最新版本
- **兼容性测试**：Chrome、Firefox、Safari、Edge前2个版本

#### 开发工具
- **IDE**：PyCharm、VS Code、Sublime Text等
- **版本控制**：Git
- **API测试**：Postman、curl等

### 4.1.3 技术栈版本

#### 后端依赖
```
flask>=3.0.0
flask-cors>=4.0.0
flask-sqlalchemy>=3.0.0
PyJWT>=2.8.0
requests>=2.31.0
```

#### 前端依赖（CDN）
- Vue.js 2.6.14
- Element UI 2.15.13
- ECharts 5.4.3
- Axios 1.6.0
- Font Awesome 5.15.4

## 4.2 核心技术难点及解决方案

### 4.2.1 JWT Token认证

#### 难点
- Token的生成和验证
- Token过期处理
- 前端Token存储和管理

#### 解决方案

**后端实现**（`app/routes/auth.py`）
```python
import jwt
from datetime import datetime, timedelta

# 生成Token
def generate_token(user_id):
    expiration_hours = Config.TOKEN_EXPIRATION_HOURS
    now = datetime.utcnow()
    expires_at = now + timedelta(hours=expiration_hours)
    
    payload = {
        'user_id': user_id,
        'exp': int(expires_at.timestamp()),
        'iat': int(now.timestamp())
    }
    token = jwt.encode(payload, Config.SECRET_KEY, algorithm='HS256')
    return token

# 验证Token
def get_user_by_token(token):
    try:
        payload = jwt.decode(token, Config.SECRET_KEY, algorithms=['HS256'])
        user_id = payload.get('user_id')
        return User.query.get(user_id)
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None
```

**前端实现**（`static/js/request.js`）
```javascript
// 请求拦截器：自动添加Token
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：处理Token过期
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response && error.response.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login.html';
    }
    return Promise.reject(error);
  }
);
```

### 4.2.2 AI流式输出

#### 难点
- SSE（Server-Sent Events）实现
- 流式数据的处理和显示
- 错误处理和连接管理

#### 解决方案

**后端实现**（`app/routes/ai.py`）
```python
from flask import Response, stream_with_context
import json

@ai_bp.route("/chat", methods=["POST"])
def chat():
    def generate():
        full_content = ""
        # 构建消息历史
        messages_history = [{"role": "system", "content": SYSTEM_PROMPT}]
        # 添加历史记录
        # ...
        
        # 调用AI API（流式）
        stream_generator = stream_client.chat_completion_stream(
            messages=messages_history,
            model=model,
            temperature=temperature,
            max_tokens=max_tokens,
        )
        
        # 逐块返回
        for chunk in stream_generator:
            if not chunk.get("success"):
                yield f"data: {json.dumps({'error': chunk.get('error')})}\n\n"
                break
            
            content = chunk.get("data", {}).get("choices", [{}])[0].get("delta", {}).get("content", "")
            if content:
                full_content += content
                yield f"data: {json.dumps({'content': content, 'done': False})}\n\n"
        
        # 结束标记
        yield "data: [DONE]\n\n"
    
    return Response(
        stream_with_context(generate()),
        mimetype="text/event-stream",
        headers={
            "X-Accel-Buffering": "no",
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        },
    )
```

**前端实现**（`static/js/apis/ai.js`）
```javascript
function sendMessage(message) {
  const eventSource = new EventSource(`/api/ai/chat`, {
    method: 'POST',
    body: JSON.stringify({ message }),
    headers: { 'Content-Type': 'application/json' }
  });
  
  // 使用fetch + ReadableStream处理SSE
  fetch('/api/ai/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({ message })
  }).then(response => {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    function readStream() {
      reader.read().then(({ done, value }) => {
        if (done) return;
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        lines.forEach(line => {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            if (data.content) {
              // 追加内容到界面
              appendMessage(data.content);
            }
            if (data.done) {
              // 完成
            }
          }
        });
        
        readStream();
      });
    }
    
    readStream();
  });
}
```

### 4.2.3 文件上传管理

#### 难点
- 文件类型和大小验证
- 文件存储路径管理
- 文件名冲突处理

#### 解决方案

**实现**（`app/routes/upload.py`）
```python
import uuid
from pathlib import Path
from datetime import datetime
from werkzeug.utils import secure_filename

def _process_file_upload(file, file_type='general'):
    # 验证文件类型
    if not _allowed_file(file.filename):
        return False, None, "不支持的文件类型"
    
    # 验证文件大小
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > Config.MAX_UPLOAD_SIZE:
        return False, None, f"文件大小超过限制（{Config.MAX_UPLOAD_SIZE / 1024 / 1024}MB）"
    
    # 生成存储路径（按日期组织）
    now = datetime.now()
    date_path = now.strftime("%Y/%m/%d")
    upload_dir = Config.UPLOAD_BASE_DIR / file_type / date_path
    upload_dir.mkdir(parents=True, exist_ok=True)
    
    # 生成唯一文件名
    ext = file.filename.rsplit('.', 1)[1].lower()
    filename = f"{uuid.uuid4().hex}.{ext}"
    filepath = upload_dir / filename
    
    # 保存文件
    file.save(str(filepath))
    
    # 返回URL
    url = f"/static/uploads/{file_type}/{date_path}/{filename}"
    return True, {"url": url}, "上传成功"
```

### 4.2.4 复杂查询优化

#### 难点
- 多条件组合查询
- 分页性能
- 关联查询优化

#### 解决方案

**实现**（`app/routes/questions.py`）
```python
@questions_bp.route("/questions", methods=["GET"])
def list_questions():
    page, page_size = _parse_pagination()
    query = Question.query.filter_by(user_id=g.current_user.id, is_deleted=False)
    
    # 关键词搜索（使用ilike进行不区分大小写匹配）
    keyword = request.args.get("keyword")
    if keyword:
        like_keyword = f"%{keyword.strip()}%"
        query = query.filter(
            or_(
                Question.title.ilike(like_keyword),
                Question.content.ilike(like_keyword),
            )
        )
    
    # 科目筛选
    subject_id = _to_int(request.args.get("subject_id"))
    if subject_id:
        query = query.filter(Question.subject_id == subject_id)
    
    # 难度筛选
    difficulty = _to_int(request.args.get("difficulty"))
    if difficulty:
        query = query.filter(Question.difficulty == difficulty)
    
    # 计算总数（在分页前）
    total = query.count()
    
    # 分页查询
    items = (
        query.order_by(Question.created_at.desc())
        .offset((page - 1) * page_size)
        .limit(page_size)
        .all()
    )
    
    return Response.success({
        "list": [_question_to_dict(item) for item in items],
        "total": total,
        "page": page,
        "page_size": page_size,
    })
```

## 4.3 关键代码片段

### 4.3.1 应用初始化

**文件**：`app/__init__.py`
```python
def create_app() -> Flask:
    ROOT_DIR = Path(__file__).resolve().parent.parent
    
    app = Flask(
        __name__,
        static_folder=str(ROOT_DIR / "static"),
        template_folder=str(ROOT_DIR / "templates"),
    )
    
    app.config.from_object(Config)
    
    # 配置CORS
    CORS(app, resources={
        r"/api/*": {
            "origins": "*",
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            "allow_headers": ["Content-Type", "Authorization"]
        }
    })
    
    # 初始化数据库
    from .models import db
    db.init_app(app)
    
    # 注册路由
    app.register_blueprint(auth_bp, url_prefix="/api/auth")
    # ... 其他路由
    
    # 认证中间件
    @app.before_request
    def require_authentication():
        path = request.path
        if path.startswith("/api/") and not path.startswith("/api/auth"):
            auth_header = request.headers.get("Authorization", "")
            if not auth_header or not auth_header.startswith("Bearer "):
                return Response.unauthorized("请先登录")
            
            token = auth_header[7:]
            user = get_user_by_token(token)
            if not user:
                return Response.unauthorized("登录已失效，请重新登录")
            g.current_user = user
    
    return app
```

### 4.3.2 数据模型定义

**文件**：`app/models/question.py`
```python
class Question(db.Model):
    __tablename__ = "questions"
    
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    subject_id = db.Column(db.Integer, db.ForeignKey("subjects.id"), nullable=False)
    question_type = db.Column(db.String(30), nullable=False, default="single_choice")
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text)
    answer = db.Column(db.Text)
    error_reason = db.Column(db.Text, nullable=False)
    difficulty = db.Column(db.Integer, nullable=False, default=2)
    review_status = db.Column(db.Integer, nullable=False, default=0)
    review_count = db.Column(db.Integer, nullable=False, default=0)
    last_review_at = db.Column(db.DateTime)
    next_review_at = db.Column(db.DateTime)
    is_important = db.Column(db.Boolean, nullable=False, default=False)
    is_mastered = db.Column(db.Boolean, nullable=False, default=False)
    mastery_status = db.Column(db.String(20), nullable=True)
    is_deleted = db.Column(db.Boolean, nullable=False, default=False)
    images = db.Column(db.Text, nullable=True)  # JSON格式
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    subject = db.relationship("Subject", back_populates="questions")
    options = db.relationship("QuestionOption", cascade="all, delete-orphan", back_populates="question")
    tags = db.relationship("QuestionTag", cascade="all, delete-orphan", back_populates="question")
    
    def to_detail_dict(self) -> dict:
        return {
            "id": self.id,
            "title": self.title,
            "content": self.content,
            "answer": self.answer,
            "error_reason": self.error_reason,
            "difficulty": self.difficulty,
            "options": [option.to_dict() for option in self.options],
            "tags": [tag.name for tag in self.tags],
            "images": json.loads(self.images) if self.images else [],
            # ... 其他字段
        }
```

### 4.3.3 复习逻辑实现

**文件**：`app/routes/reviews.py`
```python
@reviews_bp.route("/<int:question_id>", methods=["POST"])
def submit_review(question_id: int):
    question = Question.query.filter_by(
        id=question_id,
        user_id=g.current_user.id,
        is_deleted=False,
    ).first()
    if not question:
        return Response.not_found("错题不存在或已删除")
    
    payload = request.get_json(silent=True) or {}
    result = (payload.get("result") or "").strip().lower()
    if result not in {"forgot", "hard", "mastered"}:
        return Response.error("复习结果不合法")
    
    now = datetime.utcnow()
    question.review_count += 1
    question.last_review_at = now
    question.mastery_status = result
    
    if result == "mastered":
        question.review_status = 1
        question.is_mastered = True
        question.is_important = False
        question.next_review_at = None
    else:
        question.review_status = 0
        question.is_mastered = False
        question.is_important = result == "hard" or question.is_important
        question.next_review_at = now + timedelta(days=1)
    
    db.session.commit()
    return Response.success({
        "review_count": question.review_count,
        "last_review_at": question.last_review_at.strftime("%Y-%m-%d %H:%M:%S"),
        "review_status": question.review_status,
        "mastery_status": question.mastery_status,
    }, "复习结果已记录")
```

## 4.4 开发进度与里程碑

### 4.4.1 开发阶段

#### 第一阶段：项目初始化（第1周）
- [x] 项目结构搭建
- [x] 数据库设计
- [x] 基础配置
- [x] 用户认证模块

#### 第二阶段：核心功能开发（第2-3周）
- [x] 科目管理模块
- [x] 错题管理模块
- [x] 复习中心模块
- [x] 文件上传功能

#### 第三阶段：扩展功能开发（第4周）
- [x] 出卷自测模块
- [x] AI学习助手模块
- [x] 数据统计模块
- [x] 个人中心模块

#### 第四阶段：前端开发（第5-6周）
- [x] 页面UI开发
- [x] 组件开发
- [x] API集成
- [x] 图表展示

#### 第五阶段：测试与优化（第7周）
- [x] 功能测试
- [x] 性能优化
- [x] Bug修复
- [x] 文档完善

### 4.4.2 里程碑完成情况

| 里程碑 | 计划时间 | 实际时间 | 状态 | 说明 |
|--------|----------|----------|------|------|
| 项目启动 | 第1周 | 第1周 | ✅ 完成 | 项目初始化完成 |
| 核心功能完成 | 第3周 | 第3周 | ✅ 完成 | 错题管理、复习功能完成 |
| 扩展功能完成 | 第4周 | 第4周 | ✅ 完成 | AI助手、统计功能完成 |
| 前端开发完成 | 第6周 | 第6周 | ✅ 完成 | 所有页面开发完成 |
| 测试完成 | 第7周 | 第7周 | ✅ 完成 | 功能测试通过 |
| 项目交付 | 第7周 | 第7周 | ✅ 完成 | 项目可投入使用 |

### 4.4.3 代码统计

- **Python代码**：约3000行
- **JavaScript代码**：约4000行
- **HTML模板**：8个页面
- **CSS样式**：3个样式文件
- **API接口**：30+个
- **数据库表**：6个

---

**文档版本**：v1.0  
**创建日期**：2025-12-02  
**最后更新**：2025-12-02

